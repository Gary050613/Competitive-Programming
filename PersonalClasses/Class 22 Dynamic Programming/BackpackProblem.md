/*
	背包问题 
		1.基础背包
			每种物品仅有一件，要么装，要么不装
			定义状态：
				f[i][v] 表示前 i 件物品放入容量为 v 的背包可以获得的最大价值
				f[i][v] = max{f[i-1][v],f[i-1][v-w[i]]+c[i]}
					v-w[i]	: 剩下的容量 
					c[i]  	: 放入第 i 件物品的价值
			注意：
				f[i][v] 有意义的且仅当存在一个前 i 件物品的子集，其费用总和为 v
				按照这个方程递推，最终的答案不一定是 f[N][V],而是 f[N][0..V]的最大值
				需要加入一项 f[i-1][v],这样就可以保证 f[N][V] 是最后的答案 
				

				若将所有的 f[i][j] 的初始值都设为 0，f[n][v] 也会变成最后的答案 
			优化：
				 时间复杂度 ： O(N*V) 
				 空间复杂度 ： O(N*V) --> O(V) 
				 	
					主循环 i = 1 .. N，每次算出来的二维数组 f[i][0..V] 的所有值 
					那么如果只用一个数组 f[i][v] 能不能保证第 i 次循环结束后 f[v] 表示的就是我们定义的f[i][v]呢?
					f[i][v] 是由 f[i-1][v] 和 f[i-1][v-w[i]] 两个子问题递推而来的
						要求我们每次主循环中以 v = V..0 的逆序推 f[v],才能保证 f[v] 时 f[v-w[i]] 的值保存的是 f[i-1][v-w[i]] 的值
						 
				 伪代码：
				 	for i = 1 .. N
						for v = V .. 0
					 		f[v] = max{f[v],f[v-w[i]]+c[i]}; 
					其中  f[v] = max{f[v],f[v-w[i]]+c[i]}; 就相当于状态转移方程 


​				
​				
	已知有 i 个物品的重量为 wi，价值为 vi，背包总容量 W
	前   i-1 个物品： 最大价值 f(i-1,j)
	放入第 i 个物品： 背包容量减少 wi，背包总价值增加 vi
					  最大价值 f(i-1,j-wi) + vi
	推出状态转移方程
		f(i,j) = max(f(i-1,j),f(i-1,j-wi) + vi)	
		
	对 f(i)有影响的只有 f(i-1),这时可以去掉第一维，直接用 fi 来表示当前物品时背包容量为 i 的最大价值	
		f(j) = max(f(j),f(j-w)+vi)	
		
	==================================================================	
	错误代码：
	------------------------------------------------------------------	
		for(int i = 1; i <= n; i++){
			for(int l = 0; l <= W-w[i]; l++){
				f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
			}
		}
				
	ps:f[i][l+w[i]] = max(max(f[i-1][l+w[i]],f[i-1][l]+w[i]),f[i][l+w[i]]);
	==================================================================
	当前处理的物品 i 和 当前状态 f(i,j) 
	在 j >= wi，f(i,j) 是会被 f(i,j-wi)所影响的，相当于物品 i 被多次放入了背包
	 
	为了防止这种情况的发生，我们该改变枚举的顺序，从 W 枚举到 wi，这时就不会产生错误了
	因为 f(i,j) 总是在 f(i,j-wi)之前被更新 
	==================================================================	
	正确代码：
	------------------------------------------------------------------	
		for(int i = 1; i <= n; i++){
			for(int l = w; l >=w[i]; l--){
				f[l] = max(f[l], f[l + w[i]] + v[i]);
			}
		}
	==================================================================		